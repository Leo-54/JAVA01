

##### 一、java类基础知识

1、一个Java文件只能有一个public class       。一个class最多只能有一个main函数。 

2、“>>”和“>>>”的区别

3、java数据基本类型

boolean 布尔（ture or false） byte字节  short/int/long

float(后必须要有f)/double  char字符

选择和循环结构与c语言类似

当函数定义类型有static时，可以直接引用该函数

4、函数重载：函数名相同，形参列表必须有不同。

**面向对象**

使用new关键字创建对象

**构造方法**

- 构造器：

- 1. 必须和类的名字相同

1. 必须没有返回类型，也不能写void

- 作用：

1. 调用new关键字，本质是在调用构造器
2. 初始化对象的值

- 注意：

1. 定义有参构造之后，如果想使用无参构造，显示的定义一个无参的

Alt + Insert（Alt + Shift + 0)

**封装**

- 作用

- 1. 提高程序的安全性，保护数据
  2. 隐藏代码的实现细节
  3. 统一接口
  4. 系统可维护性增加了

Alt + Shift + 0(选择setter and getter)

**继承（****extends****）**

- 注意：

- 1. JAVA中类只有单继承，没有多继承

- super

- 1. super调用父类的构造方法，必须在构造方法的第一个
  2. super必须只能出现在子类的方法或者构造方法中
  3. super和this不能同时调用构造方法

- this and super

​        this ：本身调用者这个对象

​        super ：代表父类对象的应用

 前提

​        this：没有继承也可以使用

​        super：只能在继承条件下才可以使用

 构造方法

​        this（）；本类的构造

​        super（）；父类的构造   

**重写**

​    重写：需要有继承关系，子类重写父类的方法

​           方法名必须相同

​           参数列表必须相同

​           修饰符：范围可以扩大 public>protected>Default>private

​           抛出的异常：范围，可以被缩小，但不能被扩大；

​    作用

​           父类的功能，子类不一定需要或者满足 Alt+shift+0

**多态** 

​           条件:有继承关系 ；子类重写父类方法；父类引用指向子类对象 

PS: 强制转换（instanceof）[Object>Person>Student]

从低到高进行转换时需要用到instanceof，如X(低) instanceof Y(高)，当从高转换到低时，直接person obj = new Student(); ((Student)obj).go();  go（）属于Student的方法。

**抽象类（****abstract****）**

​           不能new这个抽象类，只能靠子类去实现它

​           抽象类中可以写抽象方法

**接口（****interface****）**

1. 定义一些方法，去不断实现
2. 方法默认的都是public abstract
3. 所有常量都是public static final
4. 接口不能直接被实例化；接口中没有构造方法
5. implement可以实现多个接口，如 

public class UserserviceImpl implements UserService,TimeService

1. implement后必须重写接口中的方法



#### static	

​	**注意有无static的区别**

​	**static方法**：	静态方法直接通过类名引用，且在方法中，只能使用静态变量，不能使用非静态变量。

​	禁止引用非静态方法

​	**static块**：	static变量在内存中只能有一份,只能在类第一次被加载时调用（只运行一次）。

​			static块>匿名块>构造函数

#### final

final类：没有子类继承

final方法：不能被子类改写

final字段：基本类型不能修改值，对象类型不能修改指针

#### 常量

在接口内定义的变量默认是常量，如：

```java
public interface Animal{
    string color = "white";//default:public static final
}
```

基本类型的包装类常量池：（相同的值只存储一份，目的是节省内存，共享访问）

Boolean:	true,false

Byte,Character:	\u0000---\u007f(0-127)

Short,Int,Long:	-128~127

Float,Double没有常量池

区别：

```java
string s1 = "abc";
string s2 = "abc";
string s3 = "a"+"b"+"c";
```

在其中，s1 = s2 = s3;(编译器优化)

**注意**：(栈内存和堆内存的地址不同)

常量式赋值创建，放在栈内存，将被常量化，如：

```java
Integar a = 10;
string b = "abc";
```

new对象进行创建，放在堆内存，不会被常量化，如：

```java
Integar c = new Integar(10);
string b = new string("abc");
```

常量池：1.基本类型和包装类比较，将对包装类自动拆箱

​				2.对象比较，==是比较地址（常量赋值和new创建不是同一个对象，即不相等）

​				3.加法**+**会自动拆箱

#### 字符串

字符串拼接，使用StringBuffer/StringBuilder类的append方法进行修改

关于传递的地址问题：

```java
public class ArgumentPassing{
    public static void changeValue(int a){
        a = 10;
    }
    public static void changeValue(string s1){
        s1 = "def";
    }
    public static void changeValue(stringBuffer s1){
        s1.append("def");
    }
    public static void main(String[] args){
        int a = 5;//基本类型
        String b = "abc";//不可变对象
        StringBuffer c = new StringBuffer("abc");
        changeValue(a);
        changeValue(b);
        changeValue(c);
        System.out.println(a);//5
        System.out.println(b);//"abc"
        System.out.println(c);//"abcdef"
    }
}
```

